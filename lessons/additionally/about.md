# Django Backend

`Django` - это фреймворк на языке `python`.
Т.к. к нам приходят ученики не знающие python, необходимо постепенно объяснять его основы.


К концу модуля `Введение(до магазина)` желательно, чтобы ученик знал основные типы данных,
отличал массив от ассоциативного массива. Понимал, что в объекте `request` есть словарь `POST`,
а в нём пары - ключ значение.
Не должно возникать вопросов какой тип данных у третьего 
параметра функции `render` и тому подобное.

Это не курс для преподавателей, хоть я и постарался много объяснить в шпаргалке.

Для правильных и разносторонних объяснений нужно понимать принципы построения ORM
систем, детали взаимодействия клиента и сервера, и конечно же глубокое понимание python.

Должны быть знания о структуре виртуальной среды, понимание, каким образом при написании
python терминал 'понимает' нас (речь о системных переменных).

Вы должны четко понимать, где какой тип данных и уметь ими по разному 
оперировать, уметь вкратце объяснить, что такое `csrf`, что такое контроллер,
промежуточная обработка, и т.д.

## Нужные ссылки для быстрой работы.
  * ### [Шпаргалка](https://github.com/xlartas/it-compot-backend-methods)
    Базовые примеры по работе с django проектом на python специально для этого курса. 
    В этом же репозитории лежат другие файлы которые понадобятся на курсе. 
    Этот репозиторий полностью для учеников. Скидывайте на первом уроке и пусть сохраняют себе.
    Рекомендую ознакомится до уроков. 
  * ### [Много качественных иконок](https://www.flaticon.com/)
    На курсе размер выбираем от 32x32 до 64x64, больше не понадобится. 
    Ищем на английском.

## Рекомендаций для корректного прохождения курса

* ### Общий стиль
  В программирование именование чего-либо, кроме классов всегда с маленькой буквы.
  Придерживайтесь общепринятых стилей написания:
    * `python`:`btn_change_iq`
    * `js`:`btnChangeIq`
  
  Приучайте к структурности и декомпозиции кода, понятному именованию и соблюдению форматирования. <br>
  Учим гуглить, желательно на английском.<br>
  Желательно отключать авто-переводчики на страницах.

* ### Объяснения:
    ```javascript
    const btnChangeTheme = document.querySelector('#btn-change-theme');
    btnChangeTheme.addEventListener('click', () => setTheme(!isLightTheme()));
    
    function isLightTheme() {
        return localStorage.getItem('theme') === 'true';
    }
    
    function setTheme(isLight) {
        const theme = isLight ? 'light' : 'dark';
        btnChangeTheme.src = isLight ? 
            '/static/Core/img/sun.png' : 
            '/static/Core/img/moon.png';
        document.body.setAttribute('data-bs-theme', theme);
        localStorage.setItem('theme', isLight);
    }
    
    setTheme(isLightTheme());
    ``` 
    * #### Вот так не нужно.
      В этом коде мы имеем элемент `btnChangeTheme`, который получаем через 
      `document.querySelector` по идентификатору. Этот элемент - кнопка для 
      изменения темы. Далее, мы используем `addEventListener`, чтобы привязать
      клик к функции. Эта функция вызывает `setTheme`, 
      передавая в неё результат функции `isLightTheme`. Функция `isLightTheme` проверяет 
      текущую тему, смотря значение в `localStorage`, и возвращает булево значение.
      `setTheme` меняет тему, устанавливая атрибут в теге `body` и меняет иконку кнопки, 
      используя тернарный оператор для выбора между двумя состояниями - светлой и 
      темной темой. В конце кода вызывается `setTheme(isLightTheme())`, чтобы установить 
      начальную тему при загрузке страницы.
  
    * #### Можно вот так.
      Для начала, мы получаем ссылку на элемент кнопки для смены темы. Используя функцию 
      `document.querySelector`, 
      ищем элемент с `id = #btn-change-theme`. Затем, мы назначаем этой кнопке 
      обработчик событий с помощью функции `addEventListener`. При нажатии на кнопку вызывается 
      функция `setTheme`, которая определяет, 
      какая тема сейчас активна, используя функцию `isLightTheme`. Эта функция проверяет 
      значение в `localStorage` и возвращает `true` или `false`. В зависимости от этого, 
      функция `setTheme` обновляет иконку кнопки и атрибут темы в теге `body`, что влияет 
      на визуальное оформление страницы. В итоге, мы имеем динамическую смену темы, 
      сохраняющую выбор пользователя в `localStorage` для последующих посещений.
    
    * #### Можно и когда-нибудь нужно вот так.
      `document.querySelector` - это функция, которая возвращает первый элемент в документе, 
      соответствующий указанному `CSS-селектору`. В данном случае, она ищет элемент с 
      идентификатором `btn-change-theme` и результат возвращает в константу btnChangeTheme. 
      `const` означает, что переменная `btnChangeTheme` константа и не может быть переопределена.
      
      `addEventListener` - это функция принимающая два аргумента:
      Первый - это строка `'click'`, указывающая на тип события, на которое должен 
      реагировать элемент. В данном случае, это событие клика.
      Второй - это функция, которая выполняется при срабатывании события. Здесь 
      используется стрелочная функция `() => setTheme(!isLightTheme())`, которая вызывает 
      `setTheme` с результатом, обратным результату `isLightTheme()`. 
      
      `isLightTheme` - это функция без аргументов, которая возвращает булево значение. 
      Она извлекает значение по ключу `'theme'` из `localStorage` 
      (объекта для хранения данных в браузере) и сравнивает его со строкой `'true'`,
      именно строкой, потому что локальное хранилище хранит текст.
      
      `setTheme` принимает один аргумент `isLight`, который является булевым значением.
      Внутри функции, создается переменная `theme`, значение которой зависит от `isLight`.
      Следующая строка обновляет атрибут `src` кнопки, чтобы отобразить соответствующую иконку.
      Метод `setAttribute` используется для обновления атрибута `data-bs-theme` тега `body`, 
      который влияет на стилизацию страницы. Наконец, в `localStorage` сохраняется текущее 
      состояние темы.
  
      Функция `setTheme` с результатом функции `isLightTheme` в конце нужна, чтобы установить тему 
      при первоначальной загрузке страницы в соответствии с последней выбранной темой.
  
      В итоге, мы имеем динамическую смену темы, 
      сохраняющую выбор пользователя в `localStorage` для последующих посещений.