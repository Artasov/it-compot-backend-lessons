# Продолжаем работать с пользователями.

Вспомните начало предыдущего урока и чем вообще на нем занимались.

1. ## Допишем контроллер для регистрации
   Все кроме строчки с create_user ученики уже делали, <br>
   постарайтесь минимально участвовать в написании.<br><br>
   
   Пишите код медленно с пониманием, используйте **print** если требуется.<br>
   Обратите внимание, что мы импортируем стандартного пользователя из **auth** приложения.<br>
   Вспомните что такое `objects.create`.<br>
   Так же мы используем `objects.create_user` вместо `objects.create`, это не просто так.<br>
   `create_user` это обычный `create`, но дополнительно сделана шифровка пароля.<br>
   ```python
    # Core/views.py
    from django.contrib.auth.models import User
    from django.shortcuts import render, redirect
   
    def signup(request):
        if request.method == 'POST':
            username = request.POST['username']
            email = request.POST['email']
            password = request.POST['password']
            r_password = request.POST['repeat_password']
            if password != r_password:
                return render(request, 'Core/signup.html', {
                    'error': 'Пароли не совпадают.'
                })
            User.objects.create_user(
                username=username, 
                email=email,
                password=password,
            )
            return redirect('signin')
        return render(request, 'Core/signup.html')
    ```
    
    * Сделайте отображение ошибки в случае неверно введенных паролей.
        ```html
        <!-- signup.html -->
        ...
        <h1 class="text-body text-center fw-bold mb-4">Регистрация</h1>
        {% if error %}
            <p class="text-center text-danger fw-bold">{{ error }}</p>
        {% endif %}
        ...
        ```
    Создайте пользователя через форму, перейдите в админку и откройте объект нового пользователя.<br>
    Вы увидите в поле password зашифрованный пароль и неполный хэш для расшифровки.<br>
    ```
    algorithm: pbkdf2_sha256
    iterations: 600000 
    salt: HcopBX**************** 
    hash: ZMUUCk**************************************
    ```
    Так как мы видим не полную соль и хэш, то даже администратор сайте не знает пароли своих пользователей.
    #### В конце методички подробно описано<br>как работает подобное шифрование, если будет время можете рассказать.<br> Это даст ученикам минимальное представление о шифровании.
    
   
2. ## Вход в систему `Sign in`
    После регистрации пользователь может войти в систему.<br>
    В этом процессе Django проверяет предоставленные учетные данные и, <br>
    в случае успеха, создает сессию для пользователя. Напомните, что такое сессия. <br>

    ```python
    # Core/views.py
    ...
    from django.contrib.auth import authenticate, login
     
    def signin(request):
        if request.method == 'POST':
            username = request.POST['username']
            password = request.POST['password']
            user = authenticate(
                request, username=username, password=password
            )
            if user is not None:
                login(request, user)
                return redirect('catalog')
            else:
                return render(request, 'Core/auth/signup.html', {
                    'error': 'Неверный логин или пароль.'
                })
        return render(request, 'Core/auth/signin.html')
    ```
    Добавьте отображение ошибки в шаблоне как только что делали.

3. ## Logout
    Функция `logout` из модуля `django.contrib.auth` используется для управления процессом выхода пользователя из системы. Когда эта функция вызывается, она выполняет следующие действия:

    * **_Удаление сессии пользователя_**: Django использует сессии для отслеживания состояния пользователя. Когда пользователь входит в систему, Django создает специальную запись сессии. Функция `logout` удаляет эту запись, что приводит к тому, что следующий запрос пользователя не будет ассоциирован с его предыдущей учетной записью.

    * **_Очистка данных сессии_**: Помимо удаления записи сессии, `logout` также очищает все данные, связанные с текущей сессией пользователя.

    * **_Изменение cookie_**: Django использует cookies для идентификации сессии пользователя. Функция `logout` изменяет соответствующие `cookies` таким образом, чтобы они больше не были связаны с текущей сессией пользователя.
    
    >Импортируем эту функцию внутри нашей чтобы не было конфликта имен, т.к. 
    наша и импортированная функция имеют одинаковые названия.
    ```python
    # Core/views.py
    ...
    def logout(request):
        from django.contrib.auth import logout
        logout(request)
        return redirect('signin')
    ```
    **Проверьте, что все работает, при неверных данных выдает ошибку, 
    иначе нас перенаправляет в catalog. Если выйти из аккаунта через 
    админку, а после зайти через нашу форму, то при повторном заходе в 
    админку мы уже будем аутентифицированы.**
3. ## Добавим в шапку 4 ссылки: `Профиль` `Вход` `Регистрация` `Выход`<br>
    
    ![](imgs/header.png)
    ```html
    <!-- header.html -->
    {% load static %}
    <header>
        <nav class="navbar navbar-expand-lg">
            ...
                ...
                    <ul class="navbar-nav mb-2 mb-lg-0 gap-2">
                        <li class="nav-item">
                            <a class="nav-link py-0"
                               href="{% url 'catalog' %}">
                                Catalog
                            </a>
                        </li>
                        <li class="nav-item">
                            <a class="py-0"
                               href="{% url 'profile' %}">
                                <img width="20" height="20"
                                     style="filter: invert(0.75)"
                                     src="{% static 'Core/img/user.png' %}" alt="profile">
                            </a>
                        </li>
                        <li class="nav-item my-auto">
                            <a class="btn btn-secondary py-0"
                               href="{% url 'signin' %}">
                                Sign In
                            </a>
                        </li>
                        <li class="nav-item my-auto">
                            <a class="btn btn-secondary py-0"
                               href="{% url 'signup' %}">
                                Sing Up
                            </a>
                        </li>
                        <li class="nav-item my-auto">
                            <a class="py-0"
                               href="{% url 'logout' %}">
                                <img width="24" height="24"
                                     style="filter: invert(0.75)"
                                     src="{% static 'Core/img/logout.png' %}" alt="logout">
                            </a>
                        </li>
                    </ul>
                ...
            ...
        </nav>
    </header>
    ```
## На следующем занятии мы сделаем корректное отображение этих кнопок и научимся немного работать с распределением доступа.

## Шифрование pbkdf2_sha256
`pbkdf2_sha256` относится к алгоритму хеширования паролей,<br>
который используется для обеспечения безопасности хранения паролей.<br>

Разберем этот термин по частям:<br>

`PBKDF2`: Это сокращение от "Password-Based Key Derivation Function 2". <br>
Это функция, используемая для преобразования пароля в ключ. <br>
Она применяется для увеличения сложности взлома паролей методом тупого перебора(`brute-force`).<br>
Это когда какой-то скрипт перебирает всевозможные пароли и пытается условно угадать настоящий пароль <br>
(такой процесс может длиться много дней).<br>

`PBKDF2` повторно применяет хеш-функцию многократно, что увеличивает время, необходимое для взлома пароля.<br>
Проще говоря зашифровал, потом зашифровал зашифрованное, потом это еще раз зашифровал и т.д.<br>

`SHA256`: Это алгоритм хеширования, который генерирует уникальный, фиксированный размер хеша (256 бит) из входных данных. SHA256 относится к семейству алгоритмов SHA-2, разработанных Национальным институтом стандартов и технологий США (NIST).

Процесс шифрования обычно включает следующие шаги:

`Соль (Salt)`: Сначала к паролю добавляется случайная строка (соль... перец...), <br>
чтобы сделать результат хеширования уникальным даже для одинаковых паролей.
Предположим, 2 пользователя сделают пароль 123, но при добавлении соли получится<br>
`123ngeoroi343#@` и `123WOIsgGNign334h`, это очевидно разные пароли, хотя изначально были одинаковы.

`Хеширование`: Пароль с солью подвергается многократному хешированию с использованием SHA256.<br>
Количество итераций хеширования обычно достаточно велико (тысячи, десятки тысяч раз..),<br>
что делает процесс более устойчивым к атакам методом `brute-force`.

`Хранение`: Результат хеширования (вместе с использованной солью и информацией о количестве итераций)<br>
сохраняется в базе данных.<br>
**_Это как раз то, что мы и видели в нашей базе данных._**<br>

Когда пользователь пытается войти в систему, введенный пароль обрабатывается тем же способом,<br>
и результат сравнивается с хранимым хешем. Если они совпадают, доступ предоставляется.

## Подведите итоги.
># git push...
