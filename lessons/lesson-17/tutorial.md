# Продолжаем работать с пользователями.

Вспомните начало предыдущего урока.

1. ## Допишем контроллер для регистрации
   Все кроме строчки с create_user ученики уже делали, <br>
   постарайтесь минимально участвовать в написании.<br><br>
   
   Пишите код медленно с пониманием, используйте print если требуется.<br>
   Обратите внимание, что мы импортируем стандартного пользователя из auth приложения.<br>
   Вспомните что такое `objects.create`.<br>
   Так же мы используем `objects.create_user` вместо `objects.create`, это не просто так.<br>
   `create_user` это обычный `create`, но дополнительно сделана шифровка пароля.<br>
   ```python
    # Core/views.py
    from django.contrib.auth.models import User
    from django.shortcuts import render, redirect
    def signup(request):
        if request.method == 'POST':
            username = request.POST['username']
            email = request.POST['email']
            password = request.POST['password']
            r_password = request.POST['repeat_password']
            if password != r_password:
                return render(request, 'Core/signup.html', {
                    'error': 'Пароли не совпадают.'
                })
            User.objects.create_user(
                username=username, 
                email=email,
                password=password,
            )
            return redirect('signin')
        return render(request, 'Core/signup.html')
    ```
    
    * Сделайте отображение ошибки в случае неверно введенных паролей.
        ```html
        <!-- signup.html -->
        ...
        <h1 class="text-body text-center fw-bold mb-4">Регистрация</h1>
        {% if error %}
            <p class="text-center text-danger fw-bold">{{ error }}</p>
        {% endif %}
        ...
        ```
    Создайте пользователя через форму, перейдите в админку и откройте объект нового пользователя.<br>
    Вы увидите в поле password зашифрованный пароль и неполный хэш для расшифровки.<br>
    ```
    algorithm: pbkdf2_sha256
    iterations: 600000 
    salt: HcopBX**************** 
    hash: ZMUUCk**************************************
    ```
    Так как мы видим не полную соль и хэш, то даже администратор сайте не знает пароли своих пользователей.
    #### В конце методички подробно описано<br>как работает подобное шифрование, если будет кому-то интересно можете рассказать.<br> Это даст ученикам минимальное представление о шифровании.
    
   
2. ## Вход в систему `Sign in`
    После регистрации пользователь может войти в систему.<br>
    В этом процессе Django проверяет предоставленные учетные данные и,<br>
    в случае успеха, создает сессию для пользователя. Напомните, что такое сессия.
     
    ```python
    from django.contrib.auth import authenticate, login
     
    def signin(request):
        if request.method == 'POST':
            username = request.POST['username']
            password = request.POST['password']
            user = authenticate(request, username=username, password=password)
            if user is not None:
                login(request, user)
                return redirect('dashboard')
            else:
                # Обработка ситуации с неверными данными
        return render(request, 'login.html')
    ```
  Управление доступом и правами пользователей
  После аутентификации пользователя можно применять различные уровни доступа. Django предлагает гибкие инструменты для управления правами доступа, включая группы и разрешения, а также декораторы для контроля доступа к представлениям.
   
  ```python
  from django.contrib.auth.decorators import login_required
   
  @login_required
  def secret_page(request):
      # Страница доступна только аутентифицированным пользователям
      return render(request, 'secret_page.html')
  ```
   
  Стоит рассказать на будущее, что существует множество пакетов расширяющих возможности django.
  Например django-allauth <br>
  django-allauth – это мощная библиотека для Django, предназначенная для облегчения процессов аутентификации, регистрации и управления учетными записями пользователей. Она предоставляет интеграцию с социальными сетями и другими внешними провайдерами аутентификации, что позволяет пользователям регистрироваться и входить в систему с помощью своих учетных записей в этих сервисах. Основные особенности:
   
  Поддержка множества провайдеров социальной аутентификации (например, Google, GitHub, Telegram, Vk, Twitter и т.д.).
  Интеграция с системой аутентификации Django.
  Расширенная обработка электронной почты, включая подтверждение электронной почты.
  Возможность совместного использования с другими приложениями и плагинами Django.


## Шифрование pbkdf2_sha256
`pbkdf2_sha256` относится к алгоритму хеширования паролей,<br>
который используется для обеспечения безопасности хранения паролей.<br>

Разберем этот термин по частям:<br>

`PBKDF2`: Это сокращение от "Password-Based Key Derivation Function 2". <br>
Это функция, используемая для преобразования пароля в ключ. <br>
Она применяется для увеличения сложности взлома паролей методом тупого перебора(`brute-force`).<br>
Это когда какой-то скрипт перебирает всевозможные пароли и пытается условно угадать настоящий пароль <br>
(такой процесс может длиться много дней).<br>

`PBKDF2` повторно применяет хеш-функцию многократно, что увеличивает время, необходимое для взлома пароля.<br>
Проще говоря зашифровал, потом зашифровал зашифрованное, потом это еще раз зашифровал и т.д.<br>

`SHA256`: Это алгоритм хеширования, который генерирует уникальный, фиксированный размер хеша (256 бит) из входных данных. SHA256 относится к семейству алгоритмов SHA-2, разработанных Национальным институтом стандартов и технологий США (NIST).

Процесс шифрования обычно включает следующие шаги:

`Соль (Salt)`: Сначала к паролю добавляется случайная строка (соль... перец...), <br>
чтобы сделать результат хеширования уникальным даже для одинаковых паролей.
Предположим, 2 пользователя сделают пароль 123, но при добавлении соли получится<br>
`123ngeoroi343#@` и `123WOIsgGNign334h`, это очевидно разные пароли, хотя изначально были одинаковы.

`Хеширование`: Пароль с солью подвергается многократному хешированию с использованием SHA256.<br>
Количество итераций хеширования обычно достаточно велико (тысячи, десятки тысяч раз..),<br>
что делает процесс более устойчивым к атакам методом `brute-force`.

`Хранение`: Результат хеширования (вместе с использованной солью и информацией о количестве итераций)<br>
сохраняется в базе данных.<br>
**_Это как раз то, что мы и видели в нашей базе данных._**<br>

Когда пользователь пытается войти в систему, введенный пароль обрабатывается тем же способом,<br>
и результат сравнивается с хранимым хешем. Если они совпадают, доступ предоставляется.